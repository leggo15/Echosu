{% extends 'base.html' %}
{% load static %}
{% load custom_tags %}

{% block title %}Edit Tags Descriptions{% endblock %}
{% block head_css %}
  <link rel="stylesheet" href="{% static 'css/edit_tags.css' %}">
  <link rel="stylesheet" href="{% static 'css/search_filters.css' %}">
{% endblock %}

{% block content %}
        <meta name="csrf-token" content="{{ csrf_token }}">
        <div class="container">
            <h2 class="collapsible-description-header" aria-expanded="false" aria-controls="add-beatmap-content" role="button" tabindex="0">
                Edit Tags
                <span class="arrow">&#9660;</span> <!-- Down arrow -->
            </h2>
            <div class="collapsible-description-content" id="add-beatmap-content" aria-hidden="true">
                <p>Welcome, you might wonder when you got access to this page? well this appears after youve applied tags on a certain amount of maps.</p> 
                <p>Here anyone can write a description for any tag. Then people can vote for these tag descriptions, where downvotes count negativly and upvotes count positivly, if a description reaches 10 positive votes, it locks and can no longer be edited.</p>
            </div>
            
            <!-- Search Form -->
            <form method="get" action="{% url 'edit_tags' %}" class="beatmap-form filters-card">
                <div class="search-row">
                    <input type="text" class="search-input" name="search" id="search" placeholder="Search tags..." value="{{ search_query }}">
                    <button type="submit" class="search-btn">Search</button>
                </div>
            </form>
            
            <!-- Tags Table -->
            <div class="filters-card">
            <table class="tags-table">
                <thead>
                    <tr>
                        <th>Tag Name</th>
                        <th class="narrow-column">Votes</th>
                        <th>Description <span class="muted">(max 100)</span></th>
                        <th>Edited By</th>
                    </tr>
                </thead>
                <tbody>
                    {% for tag in tags %}
                    <tr>
                        <td>
                            {{ tag.name }}
                            {% if tag.is_locked %}
                                <span class="lock-badge" title="Locked by votes">Locked</span>
                            {% endif %}
                        </td>
                        <td>
                            {% if not tag.is_locked %}
                            <div class="vote-section" data-tag-id="{{ tag.id }}">
                                <div class="vote-group vote-group--up">
                                    <button class="vote-btn upvote-btn generic_btn {% if tag.is_locked %}disabled-btn{% endif %}"
                                            {% if tag.is_locked or user_votes|get_item:tag.id %}
                                            disabled
                                            {% endif %}
                                            {% if user_votes|get_item:tag.id == 'upvote' %}
                                            style="background-color: green;"
                                            {% endif %}>
                                        ▲
                                    </button>
                                    {% if user.is_staff %}
                                      <span class="vote-count upvote-count">{{ tag.upvotes }}</span>
                                    {% endif %}
                                </div>
                                <div class="vote-sep" aria-hidden="true"></div>
                                <div class="vote-group vote-group--down">
                                    {% if user.is_staff %}
                                      <span class="vote-count downvote-count">{{ tag.downvotes }}</span>
                                    {% endif %}
                                    <button class="vote-btn downvote-btn generic_btn {% if tag.is_locked %}disabled-btn{% endif %}"
                                            {% if tag.is_locked or user_votes|get_item:tag.id %}
                                            disabled
                                            {% endif %}
                                            {% if user_votes|get_item:tag.id == 'downvote' %}
                                            style="background-color: red;"
                                            {% endif %}>
                                        ▼
                                    </button>
                                </div>
                            </div>
                            {% else %}
                                <p> Vote is locked. </p>
                            {% endif %}
                        </td>
                        
                        <td>
                            <div class="desc-wrapper">
                                <textarea class="tag-description" data-tag-id="{{ tag.id }}" rows="2" cols="50" maxlength="100" {% if tag.is_locked %}disabled{% endif %}>{{ tag.description }}</textarea>
                                <div class="desc-footer">
                                    <span class="char-count" data-for="{{ tag.id }}">{{ tag.description|length }}/100</span>
                                    <span class="save-hint">Auto-saves after pause</span>
                                </div>
                            </div>
                        </td>
                        <td>
                            {% if tag.description_author and tag.description_author.username != 'default_author' %}
                                {{ tag.description_author.username }}
                            {% else %}
                                N/A
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
            </div>
            
            <!-- Pagination Controls -->
            <div class="pagination" style="margin-top: 14px;">
                <span class="step-links">
                    {% if tags.has_previous %}
                        <a href="?search={{ search_query }}&page=1">&laquo; first</a>
                        <a href="?search={{ search_query }}&page={{ tags.previous_page_number }}">previous</a>
                    {% endif %}
    
                    <span class="current">
                        Page {{ tags.number }} of {{ tags.paginator.num_pages }}.
                    </span>
    
                    {% if tags.has_next %}
                        <a href="?search={{ search_query }}&page={{ tags.next_page_number }}">next</a>
                        <a href="?search={{ search_query }}&page={{ tags.paginator.num_pages }}">last &raquo;</a>
                    {% endif %}
                </span>
            </div>
            
            <!-- Message Area for AJAX Feedback -->
            <div id="message-area"></div>
            
            <!-- Loading Spinner -->
            <div id="loading-spinner">
                <img src="{% static 'images/spinner.gif' %}" alt="Loading...">
            </div>
            
        </div>
{% endblock %}

{% block foot_js %}
<script src="{% static 'js/collapsible_descriptions.js' %}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const descriptionFields = document.querySelectorAll('.tag-description');
        const messageArea = document.getElementById('message-area');
        const loadingSpinner = document.getElementById('loading-spinner');
        const debounceTimeout = 3000; // 3 seconds
        const debounceTimers = {};

        // Handle Description Editing with Debounce
        descriptionFields.forEach(function(field) {
            field.addEventListener('input', function() {
                const tagId = field.getAttribute('data-tag-id');
                const newDescription = field.value.trim();
                // live char count
                const counter = document.querySelector(`.char-count[data-for="${tagId}"]`);
                if (counter) { counter.textContent = `${newDescription.length}/100`; }

                // Clear existing timer if any
                if (debounceTimers[tagId]) {
                    clearTimeout(debounceTimers[tagId]);
                }

                // Set a new timer
                debounceTimers[tagId] = setTimeout(function() {
                    showLoading();
                    // AJAX request to update the tag description
                    fetch("{% url 'edit_tags' %}", {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-CSRFToken': getCSRFToken(),
                            'X-Requested-With': 'XMLHttpRequest' // Indicate AJAX request
                        },
                        body: new URLSearchParams({
                            'tag_id': tagId,
                            'description': newDescription
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'success') {
                            showMessage(`${data.message} Author: ${data.description_author}`, 'success');
                            // Update the author display in the table
                            const row = field.closest('tr');
                            if (row) {
                                const authorCell = row.querySelector('td:nth-child(4)');
                                if (authorCell) { authorCell.textContent = data.description_author; }
                            }
                            // Reset vote counts in the UI
                            const td = field.closest('tr')?.querySelector('td:nth-child(2)');
                            const voteSection = td ? td.querySelector('.vote-section') : null;
                            if (voteSection) {
                                const upC = voteSection.querySelector('.upvote-count');
                                const dnC = voteSection.querySelector('.downvote-count');
                                if (upC) upC.textContent = data.upvotes;
                                if (dnC) dnC.textContent = data.downvotes;
                                const upB = voteSection.querySelector('.upvote-btn');
                                const dnB = voteSection.querySelector('.downvote-btn');
                                if (upB) { upB.disabled = false; upB.classList.remove('disabled-btn'); upB.style.backgroundColor = ''; }
                                if (dnB) { dnB.disabled = false; dnB.classList.remove('disabled-btn'); dnB.style.backgroundColor = ''; }
                            }
                        } else {
                            showMessage(data.message, 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        showMessage('An error occurred while updating the description.', 'error');
                    })
                    .finally(() => {
                        hideLoading();
                        // Remove the timer
                        delete debounceTimers[tagId];
                    });
                }, debounceTimeout);
            });
        });

        // Handle Upvote and Downvote Buttons
        const voteSections = document.querySelectorAll('.vote-section');

        voteSections.forEach(function(voteSection) {
            const tagId = voteSection.getAttribute('data-tag-id');
            const upvoteBtn = voteSection.querySelector('.upvote-btn');
            const downvoteBtn = voteSection.querySelector('.downvote-btn');
            const upvoteCountSpan = voteSection.querySelector('.upvote-count');
            const downvoteCountSpan = voteSection.querySelector('.downvote-count');

            // Attach event listeners for voting
            upvoteBtn.addEventListener('click', function() {
                handleVote(tagId, 'upvote', upvoteCountSpan, downvoteCountSpan, voteSection);
            });

            downvoteBtn.addEventListener('click', function() {
                handleVote(tagId, 'downvote', upvoteCountSpan, downvoteCountSpan, voteSection);
            });
        });

        function handleVote(tagId, voteType, upvoteCountSpan, downvoteCountSpan, voteSection) {
            const csrfToken = getCSRFToken();

            showLoading();
            fetch("{% url 'vote_description' %}", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': csrfToken,
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: new URLSearchParams({
                    'tag_id': tagId,
                    'vote_type': voteType
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    upvoteCountSpan.textContent = data.upvotes;
                    downvoteCountSpan.textContent = data.downvotes;

                    const upvoteBtn = voteSection.querySelector('.upvote-btn');
                    const downvoteBtn = voteSection.querySelector('.downvote-btn');

                    // Reset button styles and states
                    upvoteBtn.disabled = false;
                    downvoteBtn.disabled = false;
                    upvoteBtn.style.backgroundColor = '';
                    downvoteBtn.style.backgroundColor = '';
                    upvoteBtn.classList.remove('disabled-btn');
                    downvoteBtn.classList.remove('disabled-btn');

                    if (data.removed) {
                        // Vote was removed
                        showMessage('Your vote has been removed.', 'success');
                    } else if (data.changed) {
                        // Vote was changed from one type to another
                        if (voteType === 'upvote') {
                            upvoteBtn.style.backgroundColor = 'green';
                        } else if (voteType === 'downvote') {
                            downvoteBtn.style.backgroundColor = 'red';
                        }
                        showMessage('Your vote has been updated.', 'success');
                    } else if (data.new_vote) {
                        // New vote was added
                        if (voteType === 'upvote') {
                            upvoteBtn.style.backgroundColor = 'green';
                        } else if (voteType === 'downvote') {
                            downvoteBtn.style.backgroundColor = 'red';
                        }
                        showMessage('Your vote has been recorded.', 'success');
                    }

                    // If a new vote or changed vote, disable the opposite button
                    if (data.new_vote || data.changed) {
                        if (voteType === 'upvote') {
                            downvoteBtn.disabled = true;
                            downvoteBtn.classList.add('disabled-btn');
                        } else if (voteType === 'downvote') {
                            upvoteBtn.disabled = true;
                            upvoteBtn.classList.add('disabled-btn');
                        }
                    }

                    // Lock description if vote score reaches the threshold
                    if (data.is_locked) {
                        const descriptionTextarea = document.querySelector(`.tag-description[data-tag-id="${tagId}"]`);
                        descriptionTextarea.disabled = true;

                        showMessage(`Description for tag "${data.tag_name}" has been locked due to high vote score.`, 'success');
                    }
                } else {
                    showMessage(data.message, 'error');
                }
            })
            .catch(error => {
                console.error('Error during vote request:', error);
                showMessage('An error occurred while voting.', 'error');
            })
            .finally(() => {
                hideLoading();
            });
        }

        // Function to display messages
        function showMessage(message, type) {
            messageArea.innerHTML = `<p class="${type}">${message}</p>`;
            // Remove the message after a delay
            setTimeout(() => {
                messageArea.innerHTML = '';
            }, type === 'success' ? 3000 : 5000);
        }

        // Functions to show and hide the loading spinner
        function showLoading() {
            loadingSpinner.style.display = 'block';
        }

        function hideLoading() {
            loadingSpinner.style.display = 'none';
        }

        // Function to retrieve CSRF token from meta tag
        function getCSRFToken() {
            // Attempt to get CSRF token from meta tag
            const meta = document.querySelector('meta[name="csrf-token"]');
            if (meta) {
                return meta.getAttribute('content');
            }
            // Fallback: Get CSRF token from hidden input field
            const csrfInput = document.querySelector('[name=csrfmiddlewaretoken]');
            return csrfInput ? csrfInput.value : '';
        }
    });
</script>
{% endblock %}
