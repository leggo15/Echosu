{% extends 'base.html' %}
{% load static %}

{% block title %}{{ beatmap.title }} Details{% endblock %}
{% block body_class %}page-beatmap-detail{% endblock %}

{% block head_css %}
  <link rel="stylesheet" href="{% static 'css/beatmap_card.css' %}">
  <link rel="stylesheet" href="{% static 'css/tagging.css' %}">
  <link rel="stylesheet" href="{% static 'css/search_filters.css' %}">
  <link rel="stylesheet" href="{% static 'css/rosu_graph.css' %}">
{% endblock %}

{% block content %}
  {% include 'partials/tag_card.html' with beatmap=beatmap show_details_button=False %}

  <!-- Difficulty graph -->
  <div class="rosu-graph-card">
    <div class="rosu-graph-header">
        <h3 class="rosu-graph-title">Difficulty over time</h3>
    </div>
    <div class="rosu-graph-container">
      <div class="rosu-graph-info-wrap" aria-label="Graph help">
        <button class="rosu-graph-info" type="button" title="How to use this graph" aria-describedby="rosuGraphHelp">i</button>
        <div class="rosu-graph-tooltip" id="rosuGraphHelp" role="tooltip">
          <div></div>
          <div>• Graph shows Aim/Speed/Total stars over time.</div>
          <div>• Toggle mods on the right to update the graph to reflect the modded difficulty.</div>
          <div>• If you have applied tags, you can define the time range(s) where they apply.</div>
          <div>• If multiple users define times for the same tag, the graph will show the average/agreed upon time.</div>
        </div>
      </div>
      <div class="rosu-mods-rail" aria-label="Apply mods to difficulty graph">
        <button class="mod-toggle" data-mod="DT" title="Double Time">DT</button>
        <button class="mod-toggle" data-mod="HR" title="Hard Rock">HR</button>
        <button class="mod-toggle" data-mod="FL" title="Flashlight">FL</button>
        <button class="mod-toggle" data-mod="HT" title="Half Time">HT</button>
        <button class="mod-toggle" data-mod="EZ" title="Easy">EZ</button>
      </div>
      <canvas id="rosuGraphCanvas" height="140" data-ts-url="{% url 'beatmap_timeseries' beatmap_id=beatmap.beatmap_id %}" data-total-stars="{{ beatmap.difficulty_rating|default:0 }}" data-total-length="{{ beatmap.total_length|default:0 }}"></canvas>
    </div>
  </div>

  {% if error %}
    <p class="error">{{ error }}</p>
  {% endif %}

  {% if user.is_staff %}
  <div id="api-test-output" class="api-test-output"></div>
  {% endif %}
{% endblock %}

{% block foot_js %}
  <script src="{% static 'js/tagging.js' %}"></script>
  <script src="{% static 'js/rosu_graph.js' %}"></script>
  <script src="{% static 'js/rosu_graph_tags.js' %}"></script>
  {% if user.is_staff %}
  <script>
    (function(){
      const btn = document.querySelector('.api-test-btn');
      const flushBtn = document.querySelector('.flush-predictions-btn');
      if (!btn) return;
      const output = document.getElementById('api-test-output');
      const beatmapId = btn.getAttribute('data-beatmap-id');
      const token = "{{ api_auth_token|default:'' }}";
      const currentUserId = {{ user.id|default:'null' }};
      const base = window.location.origin;

      function h(title){
        const el = document.createElement('h4');
        el.textContent = title;
        return el;
      }
      function pre(text){
        const el = document.createElement('pre');
        el.textContent = text;
        return el;
      }
      function getCookie(name){
        const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g,'\\$1') + '=([^;]*)'));
        return m ? decodeURIComponent(m[1]) : '';
      }

      async function fetchJson(url, options={}){
        const headers = Object.assign({'Accept': 'application/json'}, options.headers||{});
        if (token) headers['Authorization'] = 'Token ' + token;
        const resp = await fetch(url, Object.assign({}, options, {headers}));
        const text = await resp.text();
        let parsed;
        try { parsed = JSON.parse(text); } catch { parsed = text; }
        return {status: resp.status, data: parsed};
      }
      async function postJson(url, body){
        const headers = {'Accept':'application/json','Content-Type':'application/json'};
        const csrf = getCookie('csrftoken') || getCookie('CSRF-TOKEN') || '';
        if (csrf) headers['X-CSRFToken'] = csrf;
        if (token) headers['Authorization'] = 'Token ' + token;
        const resp = await fetch(url, {method:'POST', credentials:'same-origin', headers, body: JSON.stringify(body)});
        const text = await resp.text();
        let parsed; try { parsed = JSON.parse(text); } catch { parsed = text; }
        return {status: resp.status, data: parsed};
      }
      function hasMyTag(apps, tagName){
        const lower = String(tagName||'').trim().toLowerCase();
        return (apps||[]).some(a => a && a.user && a.user.id === currentUserId && a.tag && String(a.tag.name||'').toLowerCase() === lower);
      }
      async function getApps(){
        const url = base + `/api/tag-applications/?beatmap_id=${beatmapId}`;
        const res = await fetchJson(url);
        return Array.isArray(res.data) ? res.data : [];
      }

      async function run(){
        output.innerHTML = '';
        const endpoints = [
          // Consolidated retrieve with includes
          `/api/beatmaps/${beatmapId}/`,
          // Slim tag applications list (for comparison)
          `/api/tag-applications/?beatmap_id=${beatmapId}&include=tag_counts,tag_timestamps,predicted_tags,true_negatives`
        ];
        for (const path of endpoints){
          const url = path.startsWith('http') ? path : base + path;
          output.appendChild(h(url));
          try {
            const res = await fetchJson(url);
            output.appendChild(pre(typeof res.data === 'string' ? res.data : JSON.stringify(res.data, null, 2)));
          } catch (e) {
            output.appendChild(pre(String(e)));
          }
        }

        // --- Write API test: add and remove a tag for this admin user ---
        const toggleUrl = base + '/api/tag-applications/toggle/';
        const testTag = 'api_test';
        // Ensure clean state: if tag exists for me, remove it first
        try {
          let apps = await getApps();
          if (hasMyTag(apps, testTag)) {
            output.appendChild(h(toggleUrl + ' (POST pre-clean remove)'));
            const resClean = await postJson(toggleUrl, { beatmap_id: String(beatmapId), tags: [testTag] });
            output.appendChild(pre(typeof resClean.data === 'string' ? resClean.data : JSON.stringify(resClean.data, null, 2)));
            apps = await getApps();
          }
          // Add
          output.appendChild(h(toggleUrl + ' (POST add "' + testTag + '")'));
          const resAdd = await postJson(toggleUrl, { beatmap_id: String(beatmapId), tags: [testTag] });
          output.appendChild(pre(typeof resAdd.data === 'string' ? resAdd.data : JSON.stringify(resAdd.data, null, 2)));
          let afterAdd = await getApps();
          output.appendChild(h('Verify tag present for current user'));
          output.appendChild(pre(String(hasMyTag(afterAdd, testTag))));
          // Remove
          output.appendChild(h(toggleUrl + ' (POST remove "' + testTag + '")'));
          const resRemove = await postJson(toggleUrl, { beatmap_id: String(beatmapId), tags: [testTag] });
          output.appendChild(pre(typeof resRemove.data === 'string' ? resRemove.data : JSON.stringify(resRemove.data, null, 2)));
          let afterRemove = await getApps();
          output.appendChild(h('Verify tag removed for current user'));
          output.appendChild(pre(String(!hasMyTag(afterRemove, testTag))));
        } catch (e) {
          output.appendChild(h('Write API test error'));
          output.appendChild(pre(String(e)));
        }
      }

      btn.addEventListener('click', run);

      if (flushBtn) {
        flushBtn.addEventListener('click', async function(){
          try {
            const url = base + '/api/admin/flush/predictions/';
            const res = await postJson(url, { beatmap_id: String(beatmapId) });
            const ok = res && res.status && res.status >= 200 && res.status < 300;
            const msg = ok ? 'Flushed predictions for beatmap ' + beatmapId : 'Failed to flush predictions';
            if (output) {
              output.appendChild(h('Flush predictions'));
              output.appendChild(pre(typeof res.data === 'string' ? res.data : JSON.stringify(res.data, null, 2)));
            }
            // Trigger tag refresh
            try { window.TagManager && window.TagManager.clearTagCache && window.TagManager.clearTagCache(); } catch(e) { }
            try { window.initTaggingFor && window.initTaggingFor(document); } catch(e) { }
          } catch (e) {
            if (output) {
              output.appendChild(h('Flush predictions error'));
              output.appendChild(pre(String(e)));
            }
          }
        });
      }
    })();
  </script>
  {% endif %}
{% endblock %}
